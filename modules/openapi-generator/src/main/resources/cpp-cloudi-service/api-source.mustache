{{>licenseInfo}}
{{#operations}}

#include "{{classname}}.h"
#include "{{prefix}}Helpers.h"

namespace {{apiNamespace}}
{

using namespace {{helpersNamespace}};
{{#hasModelImport}}
using namespace {{modelNamespace}};{{/hasModelImport}}

const std::string {{classname}}::base = "{{basePathWithoutHost}}";

{{classname}}::{{classname}}(const std::shared_ptr<CloudI::API> &api)
  : m_api(api)
{
    populateValidateMap();
}

void {{classname}}::init() {
  this->setupRoutes();
}

void {{classname}}::setupRoutes() {
  int result = 0;
  {{#operation}}
  result =
      m_api->subscribe("{{{vendorExtensions.x-codegen-cloudi-path}}}", *this, &{{classname}}::{{operationIdSnakeCase}}_handler);
  assert(result == CloudI::API::return_value::success);
  {{/operation}}

  // Default handler, called when a route is not found
  result = m_api->subscribe("*", *this, &{{classname}}::{{classnameSnakeLowerCase}}_default_handler);
  assert(result == CloudI::API::return_value::success);
}

void {{classname}}::populateValidateMap() {
{{#operation}}
  endpointValidationCallbacksMap["{{basePathWithoutHost}}{{{vendorExtensions.x-codegen-cloudi-path}}}"] =
      std::bind(&{{classname}}::{{operationIdSnakeCase}}_validate_response, this, std::placeholders::_1, std::placeholders::_2);
{{/operation}}
}

{{packageName}}Error {{classname}}::handleParsingException(const std::exception& ex) const noexcept
{
  try {
    throw;
  } catch (nlohmann::detail::exception &e) {
    return {{packageName}}Error{-1, "Bad Request", "", e.what()};
  } catch ({{helpersNamespace}}::ValidationException &e) {
    return {{packageName}}Error{-1, "Bad Request", "", e.what()};
  } catch (std::exception &e) {
    return {{packageName}}Error{-1, "Internal Server Error", "", e.what()};
  }
}

{{packageName}}Error {{classname}}::handleOperationException(const std::exception& ex) const noexcept
{
  return {{packageName}}Error{-1, "Internal Server Error", "", ex.what()};
}

{{#operation}}
void {{classname}}::{{operationIdSnakeCase}}_handler(
    CloudI::API const &api, int const request_type, std::string const &name,
    std::string const &pattern, void const *const request_info,
    uint32_t const request_info_size, void const *const request,
    uint32_t const request_size, uint32_t timeout, int8_t priority,
    char const *const trans_id, char const *const pid,
    uint32_t const pid_size) {
  {{#vendorExtensions.x-codegen-cloudi-is-parsing-supported}}
  {{#bodyParam}}
  {{^isPrimitiveType}}{{^isContainer}}
  {{baseType}} {{paramName}};{{/isContainer}}{{#isArray}}std::vector<{{items.baseType}}> {{paramName}};{{/isArray}}{{#isMap}}std::map<std::string, {{items.baseType}}> {{paramName}};{{/isMap}}{{/isPrimitiveType}}
  {{/bodyParam}}
  {{#hasBodyParam}}
  {{#bodyParam}}
  {{^isPrimitiveType}}
  try {
    nlohmann::json::parse(reinterpret_cast<const char *>(request)).get_to({{paramName}});{{#isArray}}
    for (const auto& validationParam : {{paramName}})
      validationParam.validate();{{/isArray}}{{^isArray}}
    {{paramName}}.validate();{{/isArray}}
  } catch (std::exception &e) {
    {{packageName}}Error error_info;
    error_info = this->handleParsingException(e);
    API_RETURN_EINVALID_SOURCE(error_info.source.c_str());
    return;
  }
  {{/isPrimitiveType}}
  {{/bodyParam}}
  {{/hasBodyParam}}
  this->{{operationIdSnakeCase}}(api, request_type, name, pattern, request_info, request_info_size,
      request, request_size, timeout, priority, trans_id, pid, pid_size);
  {{/vendorExtensions.x-codegen-cloudi-is-parsing-supported}}
  {{^vendorExtensions.x-codegen-cloudi-is-parsing-supported}}
  this->{{operationIdSnakeCase}}(api, request_type, name, pattern, request_info, request_info_size,
      request, request_size, timeout, priority, trans_id, pid, pid_size);
  {{/vendorExtensions.x-codegen-cloudi-is-parsing-supported}}
}
{{/operation}}

void {{classname}}::{{classnameSnakeLowerCase}}_default_handler(
    CloudI::API const &api, int const request_type, std::string const &name,
    std::string const &pattern, void const *const request_info,
    uint32_t const request_info_size, void const *const request,
    uint32_t const request_size, uint32_t timeout, int8_t priority,
    char const *const trans_id, char const *const pid,
    uint32_t const pid_size) {
  API_RETURN_ENOTFOUND_SOURCE(name.c_str());
}

{{#operation}}
void {{classname}}::{{operationIdSnakeCase}}_validate_response(int status_code, const json& response) {
  switch (status_code) {
    {{#responses}}
    {{#baseType}}
    case {{{code}}}: {
      {{baseType}} responseModel;
      response.get_to(responseModel);
      responseModel.validate();
      break;
    }
    {{/baseType}}
    {{/responses}}
    default:
      throw org::openapitools::server::helpers::ValidationException("");
      break;
  }
}
{{/operation}}

void {{classname}}::api_return(int status_code, const json &response,
                               CloudI::API const &api, int const request_type,
                               std::string const &name, std::string const &pattern,
                               uint32_t timeout, char const *const trans_id, char const *const pid,
                               uint32_t const pid_size) {
  auto it = endpointValidationCallbacksMap.find(pattern);

  if (it == endpointValidationCallbacksMap.end()) {
    API_RETURN_EINVALIDRESPONSE();
    return;
  }

  EndpointValidationCallback endpointValidationFunction = it->second;
  try {
    endpointValidationFunction(status_code, response);
  } catch (std::exception &e) {
    API_RETURN_EINVALIDRESPONSE();
    return;
  }

  _api_return(status_code, response, api, request_type, name, pattern, timeout, trans_id, pid,
              pid_size);
}

void {{classname}}::_api_return(int status_code, const json &response,
                                CloudI::API const &api, int const request_type,
                                std::string const &name, std::string const &pattern,
                                uint32_t timeout, char const *const trans_id, char const *const pid,
                                uint32_t const pid_size) {
  // make response
  std::string response_{to_string(response)};

  // make reponse info
  uint32_t response_info_size_ = 0;
  char const *response_info_;
  generateResponseInfo(api, status_code, response_info_, response_info_size_);

  api.return_(request_type, name, pattern, response_info_, response_info_size_, response_.c_str(),
              response_.size(), timeout, trans_id, pid, pid_size);
}

} // namespace {{apiNamespace}}

{{/operations}}
