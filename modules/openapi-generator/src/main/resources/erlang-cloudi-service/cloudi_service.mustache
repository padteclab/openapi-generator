-module({{packageName}}).
-behaviour(cloudi_service).

%% cloudi_service callbacks
-export([cloudi_service_init/4,
         cloudi_service_handle_request/11,
         cloudi_service_handle_info/3,
         cloudi_service_terminate/3]).

-include("{{packageName}}_error.hrl").
-include("{{packageName}}_cloudi_utils.hrl").
-include_lib("cloudi_core/include/cloudi_logger.hrl").

-record(state, {
    validator_state :: jesse_state:state(),
    cloudi_pattern_operation_id_mapping :: erlang:proplist()
}).

cloudi_service_init(_Args, _Prefix, _Timeout, Dispatcher) ->
    {{packageName}}_router:prepare_validator(),
    ValidatorState = {{packageName}}_router:get_validator_state(),

    Mapping = get_subscription_paths(ValidatorState, Dispatcher),

    lists:foreach(fun({CloudiPath, OperationId}) ->
                      cloudi_service:subscribe(Dispatcher, cloudi_service_name:suffix(cloudi_service:prefix(Dispatcher),CloudiPath)),
                      ?LOG_INFO("Subscribed to path:~p. {{packageName}} Operation Id: ~p", [CloudiPath, OperationId])
                    end, Mapping),
    cloudi_service:subscribe(Dispatcher, "*"),

    {ok, #state{
        validator_state = ValidatorState,
        cloudi_pattern_operation_id_mapping = Mapping
    }}.

% Default handler
cloudi_service_handle_request(_RequestType, _Name, "{{basePathWithoutHost}}*", _RequestInfo,
                              _Request, _Timeout, _Priority, _TransId, _Pid,
                              State, _Dispatcher) ->
    ?CLOUDI_REPLY({?NOT_FOUND, [?ENOTFOUND]}, State);
cloudi_service_handle_request(RequestType, Name, Pattern, RequestInfo,
                              Request, Timeout, Priority, TransId, Pid,
                              #state{validator_state = ValidatorState,
                                     cloudi_pattern_operation_id_mapping = Mapping} = State,
                              Dispatcher) ->
    % Get operationID from the CloudI pattern
    OperationID = proplists:get_value(Pattern, Mapping),

    % Parse bindings
    {ok, Bindings} = parse_cloudi_bindings(Name, Pattern, OperationID),

    Req0 = #{body => Request, bindings => Bindings},

    case {{packageName}}_api:populate_request(OperationID, Req0, ValidatorState) of
        {ok, Populated, Req1} ->
          Response = {{packageName}}_impl:cloudi_service_handle_request(
              RequestType,
              Name,
              Pattern,
              RequestInfo,
              Request,
              Timeout,
              Priority,
              TransId,
              Pid,
              State,
              Dispatcher),
          case validate_cloudi_response(Response, OperationID, ValidatorState) of
            ok -> Response;
            _ -> ?CLOUDI_REPLY({?INTERNAL_SERVER_ERROR, [?EINVALIDRESPONSE]}, State)
          end;
        {error, Reason, _Req1} ->
          ?LOG_INFO("Invalid request:\n OperationId:~p\n Request:~p\n Reason:~p",
                    [OperationID, Req0, Reason]),
          InternalError = case Reason of
            {invalid_body, _, _} -> ?EINVALID;
            {wrong_param, _, _, _} -> ?EMISSINGFIELD
          end,
          ?CLOUDI_REPLY({?UNPROCESSABLE_ENTITY, [InternalError]}, State)
    end.

cloudi_service_handle_info(Request, State, _Dispatcher) ->
    ?LOG_WARN("Unknown info \"~p\"", [Request]),
    {noreply, State}.

cloudi_service_terminate(_Reason, _Timeout, #state{}) ->
    ok.

validate_cloudi_response(Reply, OperationID, ValidatorState) ->
    try
      case Reply of
        {reply, ResponseInfo, Response, _StateNew} ->
          HeadersOutgoing = cloudi_response_info:key_value_parse(ResponseInfo),
            case maps:find(<<"status">>, HeadersOutgoing) of
              {ok, HttpCode} ->
                _ = {{packageName}}_api:validate_response(OperationID,
                                                     binary_to_integer(HttpCode),
                                                     cloudi_x_jsx:decode(Response),
                                                     ValidatorState),
                ok;
              _ -> {error, {no_status_code}}
            end;
        _ -> {error, {invalid_reply_tuple}}
      end
    catch
     Exception -> Exception
    end.

get_subscription_paths(ValidatorState, Dispatcher) ->
    #{<<"paths">> := Paths} = jesse_state:get_current_schema(ValidatorState),
    maps:fold(fun(Path, Value, AccIn) ->
                    maps:fold(fun(Method, Value1, AccIn1) ->
                      CloudiPath = {{packageName}}_cloudi_utils:make_cloudi_path(Path, Method, Dispatcher),
                      OperationId = string:titlecase(binary_to_list(maps:get(<<"operationId">>, Value1))),
                      AccIn1 ++ [{CloudiPath, list_to_atom(OperationId)}]
                    end, [], Value) ++ AccIn
                  end, [], Paths).

%TODO: handle query parameters
parse_cloudi_bindings(Name, Pattern, OperationID) ->
    BindingParam = [Param || {Param, #{source := binding}} <-
                             [{P, {{packageName}}_api:request_param_info(OperationID, P)} || P <-
                              {{packageName}}_api:request_params(OperationID)]],
    BindingValues = [list_to_binary(V) || V <- cloudi_service_name:parse(Name, Pattern)],
    Bindings = maps:from_list(lists:zip(BindingParam, BindingValues)),
    {ok, Bindings}.
