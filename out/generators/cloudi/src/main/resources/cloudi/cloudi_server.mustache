-module({{packageName}}).
-behaviour(cloudi_service).

%% cloudi_service callbacks
-export([cloudi_service_init/4,
         cloudi_service_handle_request/11,
         cloudi_service_handle_info/3,
         cloudi_service_terminate/3]).

-include_lib("cloudi_core/include/cloudi_logger.hrl").

-record(state, {
    validator_state :: jesse_state:state(),
    cloudi_pattern_operation_id_mapping :: erlang:proplist()
}).

cloudi_service_init(_Args, _Prefix, _Timeout, Dispatcher) ->
    {{packageName}}_router:prepare_validator(),
    ValidatorState = {{packageName}}_router:get_validator_state(),

    Mapping = get_subscription_paths(ValidatorState, Dispatcher),

    lists:foreach(fun({CloudiPath, OperationId}) ->
                      cloudi_service:subscribe(Dispatcher, cloudi_service_name:suffix(cloudi_service:prefix(Dispatcher),CloudiPath)),
                      ?LOG_INFO("Subscribed to path:~p. {{packageName}} Operation Id: ~p", [CloudiPath, OperationId])
                    end, Mapping),

    {ok, #state{
        validator_state = ValidatorState,
        cloudi_pattern_operation_id_mapping = Mapping
    }}.

cloudi_service_handle_request(RequestType, Name, Pattern, RequestInfo,
                              Request, Timeout, Priority, TransId, Pid,
                              #state{validator_state = ValidatorState,
                                     cloudi_pattern_operation_id_mapping = Mapping} = State,
                              Dispatcher) ->
    % Get operationID from the CloudI pattern
    OperationID = proplists:get_value(Pattern, Mapping),

    % Parse bindings
    BindingParam = [Param || {Param, #{source := binding}} <-
                             [{P, {{packageName}}_api:request_param_info(OperationID, P)} || P <-
                              {{packageName}}_api:request_params(OperationID)]],
    BindingValues = [list_to_binary(V) || V <- cloudi_service_name:parse(Name, Pattern)],
    Bindings = maps:from_list(lists:zip(BindingParam, BindingValues)),

    Req0 = #{body => Request, bindings => Bindings},

    case {{packageName}}_api:populate_request(OperationID, Req0, ValidatorState) of
        {ok, Populated, Req1} ->
          {Code, Response0} = {{packageName}}_cloudi_logic_handler:cloudi_service_handle_request(
              RequestType,
              Name,
              Pattern,
              RequestInfo,
              Request,
              Timeout,
              Priority,
              TransId,
              Pid,
              State,
              Dispatcher),
            _ = {{packageName}}_api:validate_response(
                OperationID,
                Code,
                Response0,
                ValidatorState
            ),
          {Response, ResponseInfo} = process_response({Code, Response0}),
          {reply, ResponseInfo, Response, State};
        {error, Reason, Req1} ->
          Response = lists:flatten(io_lib:format("Unable to process request for ~p: ~p", [OperationID, Reason])),
          {reply, [{<<"status">>, <<"404">>}], <<>>, State}
    end.

cloudi_service_handle_info(Request, State, _Dispatcher) ->
    ?LOG_WARN("Unknown info \"~p\"", [Request]),
    {noreply, State}.

cloudi_service_terminate(_Reason, _Timeout, #state{}) ->
    ok.

get_subscription_paths(ValidatorState, Dispatcher) ->
    #{<<"paths">> := Paths} = jesse_state:get_current_schema(ValidatorState),
    maps:fold(fun(Path, Value, AccIn) ->
                    maps:fold(fun(Method, Value1, AccIn1) ->
                      CloudiPath = make_cloudi_path(Path, Method, Dispatcher),
                      OperationId = string:titlecase(binary_to_list(maps:get(<<"operationId">>, Value1))),
                      AccIn1 ++ [{CloudiPath, list_to_atom(OperationId)}]
                    end, [], Value) ++ AccIn
                  end, [], Paths).

make_cloudi_path(Path, Method, Dispatcher) ->
    cloudi_service:prefix(Dispatcher) ++
        re:replace(binary_to_list(Path),"{[a-zA-Z0-9]*}","?",[global,{return,list}]) ++
        "/" ++
        binary_to_list(Method).

process_response({Code, Reponse}) ->
  {cloudi_x_jsx:encode(Reponse), [{<<"status">>, list_to_binary(integer_to_list(Code))}]}.
